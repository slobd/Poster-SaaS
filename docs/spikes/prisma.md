# Prisma Research

Integrating Prisma into our platform would provide a lot of benefits over our current
solution TypeORM but also bring some challenges on board.

For a better comparison please check: [Prisma and TypeORM comparison](https://www.prisma.io/docs/concepts/more/comparisons/prisma-and-typeorm)
and specially the [Relation filters](https://www.prisma.io/docs/concepts/more/comparisons/prisma-and-typeorm#relation-filters)

For me the biggest reason to change from TypeORM to Prisma is the community and the project
maintenance. Prisma have a new community but more active, they are constantly developing new features
and even better, they are trying to build a business model on top of their open source which 
translate to people actively developing new features and fixing bugs vs one maintainer 
fixing bugs on his free time. 

Just look at the quality of their release notes:
- Prisma: https://github.com/prisma/prisma/releases
- TypeORM: https://github.com/typeorm/typeorm/releases

One of the main differences that would add some extra boilerplate is the API for creating
an Entity with nested relationship.

**TypeORM**
```ts
await this.posterRepository.save({
    tile: 'Poster 1',
    topics: [
        { name: 'Topic 1' },
        { name: 'Topic 2' },
    ]
})
```

**Prisma**

Topics 1 and 2 don't exist
```ts
await this.prisma.poster.create({
    tile: 'Poster 1',
    topics: {
        create: [
            { name: 'Topic 1' },
            { name: 'Topic 2' },
        ]
    }
})
```

Specially when the Topic entity may or may not exist
```ts
const poster = await prisma.poster.create({
    data: {
        name: 'Poster 1',
        topics: {
            connectOrCreate: [
                {
                    where: { name: topic1.name },
                    create: { name: topic1.name },
                },
                {
                    where: { name: 'Topic 2' },
                    create: { name: 'Topic 2' },
                },
            ],
        },
    },
})
```

## How to use Prisma without refactoring all the old TypeORM code

[Reference](https://www.prisma.io/docs/guides/migrate-to-prisma/migrate-from-typeorm)

In order to prevent the Prisma migration from blocking the development we need to adopt
Prisma progressively. 

We can use the `prism db pull` command to inspect the database generate by TypeORM
and generate a migration to recreate it using Prisma CLI. This will also generate models
for each table that was generated by TypeORM. All subsequent changes to the models can be
done using prisma migrations

**Scenarios:**

- In case we want to **modify an old entity** we need to update the corresponding entity definition for
TypeORM. E.g, if we modify the `Poster` model in `schema.prisma` then we need to modify
the Poster class in `poster.entity.ts`


- **Adding a new Entity with no relationship to the old Entities**: we can just add it in
the `schema.prisma` file. There shouldn't be any conflict.


- **Creating a new model and making a relationship with an old model**: Let's say, 
we want to add a `Metadata` model and made a one-to-one relationship with the `Poster` entity.
Besides, adding it to the `schema.prisma` file, we would need to also at the `Metadata` entity to the `Poster` class in `poster.entity.ts`.

```ts
// file: poster.entity.ts
class Metadata {
    id?: number
    posterId?: number
    text: string
    number: number
}

@Entity()
export class Poster {
    @PrimaryGeneratedColumn()
    id: number

    metadata?: Metadata
    
    // Other fields...
}
```

We would then need to modify the business logic to add the Metadata entry to the Poster
entity by using the PrismaClient
```ts
// file: posters-post.handler.ts
this.createdPoster = await this.posterRepository.save(newPoster)

await this.prisma.metadata.create({
    data: {
        number: 1,
        text: 'hello',
        poster: {
            connect: {
                id: this.createdPoster.id
            }
        }
    }
})

console.log('poster prisma', await this.prisma.poster.findUnique({
    where: { id: this.createdPoster.id },
    include: {
        metadata: true
    }
}))
```

This logs
```shell
poster prisma {
    id: 4,
    title: 'TEST METADATA',
    summary: null,
    description: 'dasdasd',
    createdAt: 2021-12-16T11:04:06.751Z,
    updatedAt: 2021-12-16T11:04:06.751Z,
    metadata: { id: 1, posterId: 4, text: 'hello', number: 1 }
}
```

It would still be preferable to refactor all the all TypeORM code that is affected by 
adding the `Metadata` entity. In this case it would be the whole Poster module

On the long run we should progressively refactor all the TypeORM code into Prisma. This should
not be that complicated since the business logic and the shape of the
entities should remain the same. Only thing that would change would be the data passed to the repository layer
(we need to adjust it to match the Prisma API)

## Entity Validation

Since we are using Prisma now, we no longer create `.entity.ts` files to define our entities.
Before using Prisma, we would define our TypeORM entity and also the validation schema in the
same place, and then we would use helper classes like `OmitType`, `PartialType` and `PickType`
from `@nestjs/swagger` package to create the `DTO` classes. E.g,

```ts
export class CreateGroupDto extends OmitType(Group, [
'id',
'posters',
] as const) {}
```

The problem of this approach is that it was usually hard to have visibility over the content
of the DTOs. As an example in the following case, we forgot to omit the groups property of 
the `User` entity and, therefore it is possible to and the User to a Group through the
register API what is actually not intended

```ts
export class RegisterDto extends OmitType(User, [
    'id',
    'confirmed',
    'resetPasswordToken',
    'posters',
    'avatar',
    'disableNotifications',
    'termOfUseEvent',
] as const) {}
```

Now our Dto class can be build like following (This is currently just a suggestion. We
will find out how well does this work when we start using it):

1. We create a `BaseDto` class that extends `Partial<EntityModel>`. where EntityModel comes from
`import { Entity as EntityModel } from '.prisma/client'`. The base class should have all the
properties that are shared between all the DTOs


2. We create more Dto classes as needed that extend the `BaseDto` class. We can then use 
the Schwagger utility classes to modify the BaseDto class when extending. We should avoid
as much as possible reducing visibility because of this. For the `UpdateDto`,
we can use `PartialType` to make all the properties of the `BaseDto` class optional


3. We can also use validation Groups in case of having a `BaseDto` class extended by 
more than 2 Dto classes and there is some validation that only take place in a set of them

_Note_: One of the problems with this approach is that when removing
a property from the UserModel, the BaseUserDto won't throw an error.
Therefore, every time the schema is changed we should verify the validity of the DTO
classes

Example:
```ts
class BaseUserDto implements Partial<UserModel> {
    @IsString()
    firstName: string

    @IsString()
    lastName: string

    @IsEmail()
    email: string

    @IsEmail()
    password: string

    @IsString()
    @IsOptional()
    organizationName: string | null

    @IsBoolean({ groups: ['register', 'update-subscription'] })
    subscribed: boolean

    /**
     * EXCLUDED
     */
    @Exclude()
    resetPasswordToken: string | null

    @Exclude()
    confirmed: boolean

    @Exclude()
    isDummyUser: boolean

    @Exclude()
    createdAt: Date

    @Exclude()
    updatedAt: Date
}

class CreateUserDto extends BaseUserDto {

    @IsBoolean()
    privacyPolicy: boolean

    @IsBoolean()
    termOfUse: boolean
}

class UpdateUserDto extends PartialType(BaseUserDto) {
    @IsInt()
    id: number

    @IsString()
    @IsOptional()
    currentPosition?: string

    @IsString()
    @IsOptional()
    biography?: string

    @IsBoolean()
    @IsOptional()
    disableNotifications?: boolean

    @IsBoolean()
    @IsTrue()
    @IsOptional()
    termOfUseEvent?: boolean
}

class UpdateUserSubscriptionDto extends PickType(BaseUserDto, ['subscribed']) {}
```

## Prisma Workflow

When using IntelliJ or other JetBrains product mark the folder `.\node_modules\@prisma\` 
and `.\node_modules\.prisma\`   as a "Sources Root" in order to let IntelliJ recognize 
the updated Prisma Client after running `prisma migrate dev`

[Prisma CLI reference](https://www.prisma.io/docs/reference/api-reference/command-reference)

In a development environment, you use the `prisma migrate dev` command to create and apply migrations.
This command will also reset the database.

Options:
- `--create-only` creates the migration but doesn't apply it
- `--name <NAME>` specifies the name of the migration
```shell
yarn prisma migrate dev
```

Use the `prisma db push` command if you are prototyping and are not concerned with data loss or 
replicating your changes in other environments. You can start or continue your migration 
history when you are happy with your changes.

https://www.prisma.io/docs/guides/database/prototyping-schema-db-push

```shell
yarn prisma db push
```

To apply pending migrations to production, staging, or testing environments, 
run the `prisma migrate deploy` command as part of your CI/CD pipeline

https://www.prisma.io/docs/concepts/components/prisma-migrate#production-and-testing-environments

```shell
yarn prisma migrate deploy
```

The `prisma migrate resolve` command allows you to solve migration history issues in production 
by marking a migration as already applied (supports baselining) or rolled back.

```shell
yarn prisma migrate resolve --applied
```

